<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Super Chess 8x8 (Human vs AI)</title>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<style>
  :root{ 
    --gap:2px; 
    --light:#D4BCA2; 
    --dark:#926942; 
    --bg: #05395c; 
    --text: #fff;
  }
  
  body{ 
    margin:0; 
    font-family:Arial,Helvetica,sans-serif; 
    background:var(--bg); 
    color:var(--text); 
    display:flex; 
    flex-direction:column; 
    align-items:center; 
    padding:10px; 
    user-select: none; 
    box-sizing: border-box;
    overflow-x: hidden; /* Prevent horizontal scroll */
  }
  
  h2{ 
    margin:10px 0 15px 0; 
    color:#fff; 
    text-shadow: 0 2px 4px rgba(0,0,0,0.5); 
    font-size: clamp(20px, 5vw, 32px); /* Responsive font size */
    text-align: center;
  }

  /* Top control bar */
  #topBar{ 
    display:flex; 
    gap:8px; 
    margin-bottom:10px; 
    flex-wrap: wrap; 
    justify-content: center; 
  }
  
  button{ 
    padding:8px 12px; 
    border-radius:6px; 
    border:0; 
    background:#eee; 
    color:#05395c; 
    cursor:pointer; 
    font-weight:700; 
    font-size:13px; 
    transition: all 0.2s; 
    box-shadow: 0 3px 0 #bbb;
  }
  button:hover{ background:#fff; transform: translateY(-1px); }
  button:active{ transform:translateY(2px); box-shadow: 0 1px 0 #bbb; }
  
  /* Specific button colors */
  #playAI { background:#ff6b6b; color: white; box-shadow: 0 3px 0 #c92a2a; }
  #playAI:hover { background:#ff8787; }
  #playAI:active { box-shadow: 0 1px 0 #c92a2a; }

  #playHuman { background:#51cf66; color: white; box-shadow: 0 3px 0 #2b8a3e; }
  #playHuman:hover { background:#69db7c; }
  #playHuman:active { box-shadow: 0 1px 0 #2b8a3e; }

  #resetBtn, #undoBtn, #flipBtn { background:#4dabf7; color: white; box-shadow: 0 3px 0 #1864ab;}
  #resetBtn:hover, #undoBtn:hover, #flipBtn:hover { background:#74c0fc; }
  #resetBtn:active, #undoBtn:active, #flipBtn:active { box-shadow: 0 1px 0 #1864ab; }


  /* main wrapper */
  .wrapper{ 
    display:flex; 
    flex-direction:column; 
    align-items:center; 
    width: 100%; 
    max-width: 600px; /* Limit max width for better desktop look */
  }

  /* board area with rank/file labels */
  .board-area{ 
    display:flex; 
    align-items:flex-start; 
    gap:4px; 
    width: 100%; 
  }

  /* rank labels (left) */
  .ranks{ 
    display:flex; 
    flex-direction:column; 
    justify-content:space-between; 
    height: 100%; /* Matches board height */
    font-weight:700; 
    font-size: clamp(10px, 2vw, 14px); 
    color: #ccc;
    width: 20px;
  }
  .rank-label {
      display: flex;
      align-items: center;
      justify-content: center;
      height: 12.5%; /* 100% / 8 */
  }

  /* board grid */
  #board{
    display:grid;
    grid-template-columns: repeat(8, 1fr); /* Responsive 8 cols */
    grid-template-rows: repeat(8, 1fr);    /* Responsive 8 rows */
    gap: var(--gap);
    
    width: 100%; 
    aspect-ratio: 1 / 1; /* Force Square Shape */
    background: #05395c; /* shows gap lines */
    padding:calc(var(--gap)); /* Outer padding */
    box-shadow: 0 10px 30px rgba(0,0,0,0.4);
    border-radius: 4px;
  }
  
  .square{ 
    width:100%; 
    height:100%; 
    display:flex; 
    align-items:center; 
    justify-content:center; 
    /* Responsive piece size: smaller on mobile, bigger on desktop */
    font-size: min(7vw, 55px); 
    user-select:none; 
    cursor:pointer; 
    position:relative; 
    border-radius: 2px;
  }
  .light{ background:var(--light); }
  .dark{ background:var(--dark); }

  .highlight{ outline:2px solid rgba(255, 255, 0, 0.6); box-sizing:border-box; z-index: 2; }
  .selected{ outline:2px solid #00aaff; box-sizing:border-box; z-index: 2; background-color: rgba(0,170,255,0.1); }

  /* pieces */
  .piece{ pointer-events:none; line-height: 1; }
  .white{
    color:#fff;
    text-shadow: 1px 1px 0 #000, -1px -1px 0 #000, 1px -1px 0 #000, -1px 1px 0 #000;
  }
  .black{
    color:#000;
    text-shadow: 0 0 3px rgba(255,255,255,0.6);
  }

  .square{ transition: transform 0.1s ease; }
  .square:hover{ transform: scale(1.02); z-index: 10; }

  /* file labels (bottom) */
  .files{ 
    display:flex; 
    justify-content:space-between; 
    width: 100%; /* Matches board width */
    margin-top:4px; 
    font-weight:700; 
    font-size: clamp(10px, 2vw, 14px); 
    color: #ccc;
  }
  .file-label {
      display: flex;
      align-items: center;
      justify-content: center;
      width: 12.5%; /* 100% / 8 */
  }

  /* game info */
  #gameInfo{ 
    margin-top:16px; 
    background:rgba(255,255,255,0.1); 
    padding:10px 20px; 
    border-radius:20px; 
    font-weight:700; 
    box-shadow: 0 4px 10px rgba(0,0,0,0.2); 
    font-size: 16px; 
    min-width: 200px; 
    text-align: center; 
    border: 1px solid rgba(255,255,255,0.2);
  }

  /* winner popup */
  #winnerPopup{ 
    position:fixed; 
    left:50%; top:50%; 
    transform:translate(-50%,-50%) scale(0.9); 
    background:#fff; 
    padding:24px 32px; 
    border-radius:12px; 
    box-shadow:0 15px 40px rgba(0,0,0,0.4); 
    font-weight:800; 
    font-size:24px; 
    display:none; 
    z-index:9999; 
    opacity: 0; 
    transition: all 0.3s; 
    text-align: center; 
    border: 4px solid var(--bg); 
  }
  #winnerPopup.show{ opacity: 1; transform: translate(-50%,-50%) scale(1); }
  #winnerPopup button { margin-top: 15px; width: 100%; background: var(--bg); color: #fff; }

  /* Mobile adjustment */
  @media (max-width: 500px) {
    #board { gap: 1px; padding: 2px; }
    h2 { margin-bottom: 5px; }
    #topBar { gap: 5px; }
  }
</style>
</head>
<body>
  <h2>Super Chess Engine</h2>

  <div id="topBar">
    <button id="playHuman">Human vs Human</button>
    <button id="playAI">Human vs Super AI</button>
    <div style="width:1px; background:rgba(255,255,255,0.2); margin:0 2px;"></div>
    <button id="undoBtn">Undo</button>
    <button id="flipBtn">Flip</button>
    <button id="resetBtn">Reset</button>
  </div>

  <div class="wrapper">
    <div class="board-area">
      <div class="ranks" id="ranks">
          <div class="rank-label">8</div>
          <div class="rank-label">7</div>
          <div class="rank-label">6</div>
          <div class="rank-label">5</div>
          <div class="rank-label">4</div>
          <div class="rank-label">3</div>
          <div class="rank-label">2</div>
          <div class="rank-label">1</div>
      </div>
      <div id="board" role="grid" aria-label="Chess board"></div>
    </div>
    <div class="files" id="files">
        <div class="file-label">a</div>
        <div class="file-label">b</div>
        <div class="file-label">c</div>
        <div class="file-label">d</div>
        <div class="file-label">e</div>
        <div class="file-label">f</div>
        <div class="file-label">g</div>
        <div class="file-label">h</div>
    </div>
    <div id="gameInfo">Turn: White</div>
  </div>

  <div id="winnerPopup">
    <div id="winnerText">White Wins!</div>
    <button onclick="document.getElementById('winnerPopup').classList.remove('show')">Close</button>
  </div>

<script>
/* ------------------------------
   Pieces (Unicode)
   ------------------------------ */
const PIECES = {
  "r":"♜","n":"♞","b":"♝","q":"♛","k":"♚","p":"♟",
  "R":"♖","N":"♘","B":"♗","Q":"♕","K":"♔","P":"♙"
};

/* ------------------------------
   Chess Engine (Logic)
   ------------------------------ */
class ChessGame {
  constructor(){ this.reset(); this.history = []; }
  reset(){
    this.turn="w"; this.enPassant=null; this.selected=null;
    this.board=[
      ["r","n","b","q","k","b","n","r"],
      ["p","p","p","p","p","p","p","p"],
      ["","","","","","","",""],
      ["","","","","","","",""],
      ["","","","","","","",""],
      ["","","","","","","",""],
      ["P","P","P","P","P","P","P","P"],
      ["R","N","B","Q","K","B","N","R"]
    ];
    this.history = [];
  }

  cloneBoard(){ return this.board.map(row => row.slice()); }
  saveState(){
    this.history.push({
      board: this.cloneBoard(),
      turn: this.turn,
      enPassant: this.enPassant ? [...this.enPassant] : null
    });
    if(this.history.length>50) this.history.shift(); // Limit history
  }
  undo(){
    if(this.history.length===0) return false;
    const s = this.history.pop();
    this.board = s.board.map(r=>r.slice());
    this.turn = s.turn;
    this.enPassant = s.enPassant;
    return true;
  }

  inBounds(r,c){ return r>=0 && r<8 && c>=0 && c<8; }
  isWhite(p){ return p && p===p.toUpperCase(); }
  isBlack(p){ return p && p===p.toLowerCase(); }
  opp(p1,p2){ return p1 && p2 && (this.isWhite(p1) !== this.isWhite(p2)); }

  movesFor(r,c){
    const p=this.board[r][c]; if(!p) return [];
    const isW=this.isWhite(p); const moves=[];
    if(p.toLowerCase()==="p"){
      const dir=isW?-1:1, start=isW?6:1;
      if(this.inBounds(r+dir,c) && !this.board[r+dir][c]) moves.push([r+dir,c]);
      if(r===start && this.inBounds(r+dir,c) && !this.board[r+dir][c] && this.inBounds(r+2*dir,c) && !this.board[r+2*dir][c]) moves.push([r+2*dir,c]);
      for(const dc of [-1,1]){ const rr=r+dir, cc=c+dc; if(this.inBounds(rr,cc) && this.board[rr][cc] && this.opp(p,this.board[rr][cc])) moves.push([rr,cc]); }
      if(this.enPassant){ const [er,ec]=this.enPassant; if(er===r+dir && Math.abs(ec-c)===1) moves.push([er,ec]); }
    }
    if(p.toLowerCase()==="n"){
      const steps=[[1,2],[2,1],[2,-1],[1,-2],[-1,-2],[-2,-1],[-2,1],[-1,2]];
      for(const [dr,dc] of steps){ const nr=r+dr,nc=c+dc; if(this.inBounds(nr,nc)&&(!this.board[nr][nc]||this.opp(p,this.board[nr][nc]))){moves.push([nr,nc]);} }
    }
    const dirs={b:[[1,1],[1,-1],[-1,1],[-1,-1]],r:[[1,0],[-1,0],[0,1],[0,-1]],q:[[1,1],[1,-1],[-1,1],[-1,-1],[1,0],[-1,0],[0,1],[0,-1]]};
    const t=p.toLowerCase(); if(["b","r","q"].includes(t)){
      for(const [dr,dc] of dirs[t]){ let nr=r+dr,nc=c+dc; while(this.inBounds(nr,nc)){ if(!this.board[nr][nc]) moves.push([nr,nc]); else{ if(this.opp(p,this.board[nr][nc])) moves.push([nr,nc]); break;} nr+=dr; nc+=dc; } }
    }
    if(t==="k"){ for(let dr=-1;dr<=1;dr++){ for(let dc=-1;dc<=1;dc++){ if(dr===0&&dc===0) continue; const nr=r+dr,nc=c+dc; if(this.inBounds(nr,nc)&&(!this.board[nr][nc]||this.opp(p,this.board[nr][nc]))) moves.push([nr,nc]); } } }
    return moves;
  }

  findKing(color){
    for(let r=0;r<8;r++) for(let c=0;c<8;c++){
      const p = this.board[r][c];
      if(p){ if(color==='w' && p==='K') return [r,c]; if(color==='b' && p==='k') return [r,c]; }
    }
    return null;
  }

  isSquareAttacked(attackerColor, r, c){
    for(let rr=0; rr<8; rr++){
      for(let cc=0; cc<8; cc++){
        const p = this.board[rr][cc];
        if(!p) continue;
        const pColor = this.isWhite(p) ? 'w' : 'b';
        if(pColor !== attackerColor) continue;
        const t = p.toLowerCase();
        if(t==='p'){
          const dir = (attackerColor==='w') ? -1 : 1;
          if(rr+dir === r && (cc-1 === c || cc+1 === c)) return true;
          continue;
        }
        if(t==='n'){
          const deltas = [[1,2],[2,1],[2,-1],[1,-2],[-1,-2],[-2,-1],[-2,1],[-1,2]];
          for(const [dr,dc] of deltas) if(rr+dr===r && cc+dc===c) return true;
          continue;
        }
        if(t==='k'){
          if(Math.abs(rr-r)<=1 && Math.abs(cc-c)<=1) return true;
          continue;
        }
        const diag = (t==='b' || t==='q');
        const straight = (t==='r' || t==='q');
        if(diag || straight){
          const directions = [];
          if(diag) directions.push([1,1],[1,-1],[-1,1],[-1,-1]);
          if(straight) directions.push([1,0],[-1,0],[0,1],[0,-1]);
          for(const [dr,dc] of directions){
            let tr = rr+dr, tc = cc+dc;
            while(this.inBounds(tr,tc)){
              if(tr===r && tc===c) return true;
              if(this.board[tr][tc]) break;
              tr += dr; tc += dc;
            }
          }
        }
      }
    }
    return false;
  }

  isInCheck(color){
    const king = this.findKing(color);
    if(!king) return true;
    const enemy = (color==='w') ? 'b' : 'w';
    return this.isSquareAttacked(enemy, king[0], king[1]);
  }

  wouldBeInCheckAfterMove(from, to, color){
    const savedFrom = this.board[from[0]][from[1]];
    const savedTo = this.board[to[0]][to[1]];
    let enpSaved = null;
    if(this.enPassant && savedFrom && savedFrom.toLowerCase()==='p'){
      const ep = this.enPassant;
      if(to[0] === ep[0] && to[1] === ep[1]){
        const capR = (savedFrom===savedFrom.toUpperCase()) ? to[0]+1 : to[0]-1;
        enpSaved = this.board[capR][to[1]];
        this.board[capR][to[1]] = "";
      }
    }
    this.board[to[0]][to[1]] = savedFrom;
    this.board[from[0]][from[1]] = "";

    const res = this.isInCheck(color);

    this.board[from[0]][from[1]] = savedFrom;
    this.board[to[0]][to[1]] = savedTo;
    if(enpSaved !== null){
      const capR = (savedFrom===savedFrom.toUpperCase()) ? to[0]+1 : to[0]-1;
      this.board[capR][to[1]] = enpSaved;
    }
    return res;
  }

  legalMovesFor(r,c){
    const pseudo = this.movesFor(r,c);
    const p = this.board[r][c];
    if(!p) return [];
    const color = this.isWhite(p) ? 'w' : 'b';
    const legal = [];
    for(const mv of pseudo){
      if(!this.wouldBeInCheckAfterMove([r,c], mv, color)){
        legal.push(mv);
      }
    }
    return legal;
  }

  move(from,to){
    this.saveState();
    let [r1,c1]=from,[r2,c2]=to;
    const p=this.board[r1][c1]; if(!p) return false;

    // en-passant capture
    if(this.enPassant && r2===this.enPassant[0] && c2===this.enPassant[1]) {
      const capR = r1;
      this.board[capR][c2]="";
    }

    this.enPassant=null;
    if(p.toLowerCase()==="p" && Math.abs(r2-r1)===2) this.enPassant=[(r1+r2)/2,c1];

    this.board[r2][c2]=p;
    this.board[r1][c1]="";

    // Promotion
    if((p==="P" && r2===0) || (p==="p" && r2===7)){
      const color = p==="P" ? "w" : "b";
      if(color === 'w' && !AI) { 
          onPromotion(r2,c2,color); return true; 
      } else if (color === 'b' && AI) {
          this.board[r2][c2] = "q"; // AI promotes Queen
          this.turn = "w";
          return true;
      } else {
          onPromotion(r2,c2,color); return true;
      }
    } else {
      this.turn = this.turn==="w" ? "b" : "w";
    }
    return true;
  }
}

/* ------------------------------
   Super AI (Minimax + AlphaBeta)
   ------------------------------ */
const pieceValues = { p: 100, n: 320, b: 330, r: 500, q: 900, k: 20000 };
const pst = {
  p: [
    [0,  0,  0,  0,  0,  0,  0,  0],
    [50, 50, 50, 50, 50, 50, 50, 50],
    [10, 10, 20, 30, 30, 20, 10, 10],
    [5,  5, 10, 25, 25, 10,  5,  5],
    [0,  0,  0, 20, 20,  0,  0,  0],
    [5, -5,-10,  0,  0,-10, -5,  5],
    [5, 10, 10,-20,-20, 10, 10,  5],
    [0,  0,  0,  0,  0,  0,  0,  0]
  ],
  n: [
    [-50,-40,-30,-30,-30,-30,-40,-50],
    [-40,-20,  0,  0,  0,  0,-20,-40],
    [-30,  0, 10, 15, 15, 10,  0,-30],
    [-30,  5, 15, 20, 20, 15,  5,-30],
    [-30,  0, 15, 20, 20, 15,  0,-30],
    [-30,  5, 10, 15, 15, 10,  5,-30],
    [-40,-20,  0,  5,  5,  0,-20,-40],
    [-50,-40,-30,-30,-30,-30,-40,-50]
  ],
  generic: [
    [0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0]
  ]
};

function getPstValue(piece, r, c) {
  const type = piece.toLowerCase();
  const table = pst[type] || pst.generic;
  let val = 0;
  if (piece === piece.toUpperCase()) val = table[7-r][c];
  else val = table[r][c];
  return val;
}

function evaluateBoard(board) {
  let score = 0;
  for (let r = 0; r < 8; r++) {
    for (let c = 0; c < 8; c++) {
      const p = board[r][c];
      if (!p) continue;
      const val = pieceValues[p.toLowerCase()];
      const posVal = getPstValue(p, r, c);
      if (p === p.toUpperCase()) score += (val + posVal);
      else score -= (val + posVal);
    }
  }
  return score;
}

function getAllMoves(board, color) {
  let moves = [];
  for(let r=0;r<8;r++) {
    for(let c=0;c<8;c++) {
      const p = board[r][c];
      if(p && ((color==='w' && p===p.toUpperCase()) || (color==='b' && p===p.toLowerCase()))) {
        const originalBoard = game.cloneBoard();
        game.board = board; 
        const pseudos = game.movesFor(r,c);
        for(const m of pseudos){
             if(!game.wouldBeInCheckAfterMove([r,c], m, color)){
                 moves.push({ from:[r,c], to:m, val: board[m[0]][m[1]] ? pieceValues[board[m[0]][m[1]].toLowerCase()] : 0 });
             }
        }
        game.board = originalBoard; 
      }
    }
  }
  moves.sort((a,b) => b.val - a.val);
  return moves;
}

const MAX_DEPTH = 3;

function minimax(depth, alpha, beta, isMaximizing) {
  if (depth === 0) return evaluateBoard(game.board);
  const color = isMaximizing ? 'w' : 'b';
  const moves = getAllMoves(game.board, color);
  if (moves.length === 0) {
    if (game.isInCheck(color)) return isMaximizing ? -100000 : 100000;
    return 0; 
  }
  if (isMaximizing) {
    let maxEval = -Infinity;
    for (const move of moves) {
      const captured = game.board[move.to[0]][move.to[1]];
      const moved = game.board[move.from[0]][move.from[1]];
      const oldEnPassant = game.enPassant;
      game.board[move.to[0]][move.to[1]] = moved;
      game.board[move.from[0]][move.from[1]] = "";
      if(moved.toLowerCase()==='p' && Math.abs(move.to[0]-move.from[0])===2) game.enPassant=[(move.from[0]+move.to[0])/2,move.from[1]];
      else game.enPassant=null;
      
      const ev = minimax(depth - 1, alpha, beta, false);
      
      game.board[move.from[0]][move.from[1]] = moved;
      game.board[move.to[0]][move.to[1]] = captured;
      game.enPassant = oldEnPassant;
      maxEval = Math.max(maxEval, ev);
      alpha = Math.max(alpha, ev);
      if (beta <= alpha) break;
    }
    return maxEval;
  } else {
    let minEval = Infinity;
    for (const move of moves) {
      const captured = game.board[move.to[0]][move.to[1]];
      const moved = game.board[move.from[0]][move.from[1]];
      const oldEnPassant = game.enPassant;
      game.board[move.to[0]][move.to[1]] = moved;
      game.board[move.from[0]][move.from[1]] = "";
      if(moved.toLowerCase()==='p' && Math.abs(move.to[0]-move.from[0])===2) game.enPassant=[(move.from[0]+move.to[0])/2,move.from[1]];
      else game.enPassant=null;

      const ev = minimax(depth - 1, alpha, beta, true);

      game.board[move.from[0]][move.from[1]] = moved;
      game.board[move.to[0]][move.to[1]] = captured;
      game.enPassant = oldEnPassant;
      minEval = Math.min(minEval, ev);
      beta = Math.min(beta, ev);
      if (beta <= alpha) break;
    }
    return minEval;
  }
}

function getBestMove() {
  let bestVal = Infinity;
  let bestMove = null;
  const moves = getAllMoves(game.board, 'b');
  if (moves.length === 0) return null;
  for (const move of moves) {
    const captured = game.board[move.to[0]][move.to[1]];
    const moved = game.board[move.from[0]][move.from[1]];
    const oldEnPassant = game.enPassant;
    game.board[move.to[0]][move.to[1]] = moved;
    game.board[move.from[0]][move.from[1]] = "";
    if(moved.toLowerCase()==='p' && Math.abs(move.to[0]-move.from[0])===2) game.enPassant=[(move.from[0]+move.to[0])/2,move.from[1]];
    else game.enPassant=null;
    const moveVal = minimax(MAX_DEPTH - 1, -Infinity, Infinity, true);
    game.board[move.from[0]][move.from[1]] = moved;
    game.board[move.to[0]][move.to[1]] = captured;
    game.enPassant = oldEnPassant;
    if (moveVal < bestVal) {
      bestVal = moveVal;
      bestMove = move;
    }
  }
  return bestMove;
}

/* ------------------------------
   Promotion UI
   ------------------------------ */
function onPromotion(r,c,color){
  const promoDiv = document.createElement("div");
  promoDiv.style.position = "fixed";
  promoDiv.style.left="50%"; promoDiv.style.top="50%";
  promoDiv.style.transform="translate(-50%,-50%)";
  promoDiv.style.background="#fff";
  promoDiv.style.border="4px solid #05395c";
  promoDiv.style.padding="15px";
  promoDiv.style.zIndex=2000;
  promoDiv.style.display="flex"; promoDiv.style.gap="10px";
  promoDiv.style.borderRadius="8px";
  promoDiv.style.boxShadow = "0 10px 30px rgba(0,0,0,0.5)";

  const choices = color==="w" ? ["Q","R","B","N"] : ["q","r","b","n"];
  choices.forEach(piece=>{
    const btn = document.createElement("button");
    btn.style.fontSize = "30px"; btn.style.width="50px"; btn.style.height="50px";
    btn.style.background="#05395c"; btn.style.color="#fff";
    btn.style.borderRadius="4px";
    btn.textContent = PIECES[piece];
    btn.onclick = ()=>{
      game.board[r][c] = piece;
      document.body.removeChild(promoDiv);
      game.turn = game.turn==="w" ? "b" : "w";
      render();
      updateInfo();
      if(AI && game.turn==="b") setTimeout(aiMove,100);
      postMoveChecks();
    };
    promoDiv.appendChild(btn);
  });
  document.body.appendChild(promoDiv);
}

/* ------------------------------
   UI & Controls
   ------------------------------ */
const boardDiv = document.getElementById("board");
const gameInfoDiv = document.getElementById("gameInfo");
const winnerPopup = document.getElementById("winnerPopup");
const winnerText = document.getElementById("winnerText");

let flipped=false;
let legal=[]; 
let AI=false;

function render(){
  boardDiv.innerHTML = "";
  for(let r=0;r<8;r++){
    for(let c=0;c<8;c++){
      const dr = flipped ? 7-r : r;
      const dc = flipped ? 7-c : c;

      const sq = document.createElement("div");
      sq.className = "square " + (((r+c)%2===0) ? "light" : "dark");
      sq.dataset.r = dr; sq.dataset.c = dc;
      
      const p = game.board[dr][dc];
      if(p){
        const span = document.createElement("span");
        span.className = "piece " + (p===p.toUpperCase() ? "white" : "black");
        span.textContent = PIECES[p];
        sq.appendChild(span);
      }
      boardDiv.appendChild(sq);
    }
  }
  updateInfo();
}

function updateInfo(msg){
  let status = msg ? ` — ${msg}` : "";
  gameInfoDiv.textContent = `Turn: ${game.turn==="w" ? "White" : "Black"}${status}`;
}

// Input Handling
boardDiv.addEventListener("click", (e)=>{
  let el = e.target;
  if(!el.classList.contains("square")) el = el.closest(".square");
  if(!el) return;
  const r = +el.dataset.r; const c = +el.dataset.c;
  const p = game.board[r][c];

  if(AI && game.turn==="b") return;

  if(p && ((game.turn==="w" && game.isWhite(p)) || (game.turn==="b" && game.isBlack(p)))){
    game.selected = [r,c];
    legal = game.legalMovesFor(r,c);
    render();
    highlightSquares(legal);
    const sel = boardDiv.querySelector(`[data-r='${r}'][data-c='${c}']`);
    if(sel) sel.classList.add("selected");
    return;
  }

  if(game.selected){
    for(const [rr,cc] of legal){
      if(rr===r && cc===c){
        game.move(game.selected,[r,c]);
        render();
        postMoveChecks();
        if(AI && game.turn==="b") setTimeout(aiMove,250);
        break;
      }
    }
    game.selected = null; legal = [];
    render();
  }
});

function highlightSquares(lst){
  for(const [rr,cc] of lst){
    const sq = boardDiv.querySelector(`[data-r='${rr}'][data-c='${cc}']`);
    if(sq) sq.classList.add("highlight");
  }
}

/* ------------------------------
   AI Execution
   ------------------------------ */
function aiMove(){
  updateInfo("AI Thinking...");
  setTimeout(() => {
    const best = getBestMove();
    if(best){
      game.move(best.from, best.to);
    } else {
      // Checkmate/Stalemate logic handled in postMoveChecks
    }
    render();
    postMoveChecks();
  }, 100);
}

/* ------------------------------
   Game Over Checks
   ------------------------------ */
function postMoveChecks(){
  const cur = game.turn;
  const anyLegal = playerHasAnyLegalMove(cur);
  if(!anyLegal){
    if(game.isInCheck(cur)){
      const winner = cur==='w' ? 'Black' : 'White';
      showWinner(winner);
    } else {
      updateInfo("Stalemate — Draw");
      showWinner("Draw");
    }
  }
}

function playerHasAnyLegalMove(color){
  for(let r=0;r<8;r++) for(let c=0;c<8;c++){
    const p = game.board[r][c];
    if(!p) continue;
    const pColor = game.isWhite(p) ? 'w' : 'b';
    if(pColor !== color) continue;
    if(game.legalMovesFor(r,c).length > 0) return true;
  }
  return false;
}

function showWinner(who){
  winnerText.textContent = (who === "Draw") ? "Stalemate!" : `Congratulations ${who} Win!`;
  winnerPopup.classList.add("show");
}

/* ------------------------------
   Button Listeners
   ------------------------------ */
document.getElementById("undoBtn").onclick = ()=>{
  if(AI) { game.undo(); game.undo(); } else { game.undo(); }
  render();
};

document.getElementById("resetBtn").onclick = ()=>{
  game.reset(); render();
};

document.getElementById("flipBtn").onclick = ()=>{
  flipped = !flipped; render();
};

document.getElementById("playHuman").onclick = ()=>{
  AI = false; game.reset(); flipped = false; render();
};

document.getElementById("playAI").onclick = ()=>{
  AI = true; game.reset(); flipped = false; render();
};

/* ------------------------------
   Init
   ------------------------------ */
const game = new ChessGame();
render();
window._game = game;

</script>
</body>
</html>