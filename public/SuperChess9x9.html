<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>TheGrandChess9 — Modern Rebuild</title>
<style>
  :root{
    --bg:#0f1724;
    --panel:#0b1220;
    --muted:#9aa4b2;
    --accent:#2dd4bf;
    --glass: rgba(255,255,255,0.035);
    --white:#eef2f7;
    --light-square:#f7efe1;
    --dark-square:#caa46a;
  }
  *{box-sizing:border-box}
  html,body{
    height:100%;
    margin:0;
    font-family:Inter,ui-sans-serif,system-ui,-apple-system,"Segoe UI",Roboto,"Helvetica Neue",Arial;
    color:var(--white);
    background:linear-gradient(180deg,#071128 0%, #0e1a2b 100%);
    -webkit-font-smoothing:antialiased;
  }
  .container{
    max-width:1000px;
    margin:28px auto;
    padding:20px;
    display:flex;
    flex-direction:column;
    gap:18px;
    align-items:center;
  }

  /* HEADER */
  header.app{
    width:100%;
    display:flex;
    flex-direction:column;
    align-items:center;
    justify-content:center;
    gap:6px;
  }
  .brand{
    display:flex;
    flex-direction:column;
    align-items:center;
    justify-content:center;
    text-align:center;
    width:100%;
    gap:10px;
  }
  .logo{
    width:60px;
    height:auto;
    margin-bottom:8px;
    border-radius:10px;
    background:linear-gradient(135deg,var(--accent),#60a5fa);
    display:flex;
    align-items:center;
    justify-content:center;
    font-weight:800;
    color:#042028;
  }
  h1{margin:0;font-size:18px}
  .small{font-size:13px;color:var(--muted)}

  .controls{
    margin-left:0;
    display:flex;
    gap:8px;
    align-items:center;
    flex-wrap:wrap;
    justify-content:center;
  }
  .mode-btn{
    background:transparent;
    border:1px solid rgba(255,255,255,0.06);
    padding:8px 12px;
    border-radius:8px;
    color:var(--white);
    cursor:pointer;
    font-weight:700;
  }
  .mode-btn.active{
    background:linear-gradient(90deg,#e6fffa20,#dbeafe20);
    color:var(--accent);
    border-color:rgba(45,156,219,0.25);
  }
  .action-btn{
    background:var(--glass);
    border:1px solid rgba(255,255,255,0.04);
    padding:8px 12px;
    border-radius:10px;
    color:var(--white);
    cursor:pointer;
    font-weight:900;
  }
  .action-btn.ghost{
    background:transparent;
    border:1px solid rgba(255,255,255,0.06);
  }
  .room-badge{
    background:#063;
    color:#dfffe7;
    padding:6px 10px;
    border-radius:8px;
    font-weight:900;
    display:none;
  }

  /* BOARD + INFO LAYOUT */
  .board-wrap{
    background:linear-gradient(180deg,#b3cdf2 0%, #f2d0f2 100%);
    padding:14px;
    border-radius:14px;
    box-shadow:0 10px 30px rgba(0,0,0,0.6);
    display:flex;
    flex-direction:row;
    align-items:stretch;         /* equal height columns */
    gap:16px;
    width:100%;
  }

  .board-panel{
    background:var(--panel);
    padding:14px;
    border-radius:12px;
    display:flex;
    flex-direction:column;
    gap:12px;
    flex:1 1 0;
    align-items:center;
  }

  /* BOARD + RANK LABELS */
  .board-row-wrap{
    display:flex;
    gap:10px;
    align-items:stretch;        /* rank-labels + board same height */
    width:100%;
    max-width:640px;
  }

  #board{
    width:100%;
    max-width:640px;
    aspect-ratio:1/1;
    display:grid;
    grid-template-columns:repeat(9,1fr);
    grid-template-rows:repeat(9,1fr);
    gap:3px;                   /* squares ke beech gap */
    padding:2px;
    background:#000;           /* gap ka color */
    border-radius:10px;
    overflow:hidden;
  }

.cell{
  border-radius:3px;
}
  .cell{
    width:100%;
    height:100%;
    display:flex;
    align-items:center;
    justify-content:center;
    cursor:pointer;
    position:relative;
  }
  .cell.light{background:var(--light-square)}
  .cell.dark{background:var(--dark-square)}
  img.piece{
    width:74%;
    height:74%;
    object-fit:contain;
    pointer-events:none;
    user-select:none;
  }
  .last-move{box-shadow:inset 0 0 0 5px rgba(0,0,0,0.06);}
  .selected{outline:4px solid rgba(45,156,219,0.95);outline-offset:-3px;border-radius:6px}
  .highlight{outline:4px solid rgba(46,204,113,0.95);outline-offset:-3px;border-radius:6px}
  .c-choose{outline:5px solid #f59e0b;outline-offset:-3px;border-radius:6px}

  /* RANK LABELS 1–9 */
  .rank-labels{
    display:flex;
    flex-direction:column;
    gap:0;
    margin-right:6px;
    height:100%;
  }
  .rank-label{
    width:26px;
    flex:1 1 0;                /* 9 equal rows */
    display:flex;
    align-items:center;
    justify-content:center;
    color:var(--muted);
    font-weight:800;
    font-size:13px;
  }

  /* FILE LABELS a–i */
  .file-labels{
    display:flex;
    gap:0;
    margin-top:8px;
    justify-content:center;
    width:100%;
    max-width:640px;
  }
  .file-label{
    flex:1 1 0;                /* 9 equal columns */
    display:flex;
    align-items:center;
    justify-content:center;
    color:var(--muted);
    font-weight:800;
  }

  /* INFO PANEL */
  aside.info-panel{
    background:linear-gradient(180deg,#071428 0%, #81baeb 100%);
    padding:18px;
    border-radius:12px;
    color:var(--muted);
    display:flex;
    flex-direction:column;
    gap:12px;
    flex:0 0 260px;            /* width ~260, height flexbox se stretch */
  }
  .status{color:var(--white);font-weight:800}
  .moves{
    background:var(--glass);
    padding:8px;
    border-radius:8px;
    height:260px;
    overflow:auto;
    color:var(--white);
    font-family:monospace;
  }

  footer{
    text-align:center;
    color:var(--muted);
    font-size:13px;
    margin-top:8px;
  }

  /* Rules / pieces boxes (tumhare paste se) */
  .compact-row{
    display:flex;
    justify-content:space-between;
    flex-wrap:nowrap;
    margin:10px 0;
  }
  .piece-box{
    width:70px;
    background:#ceedc5;
    border-radius:6px;
    padding:6px;
    text-align:center;
    box-shadow:0 2px 5px rgba(0,0,0,0.15);
  }
  .piece-box img{
    width:42px;
    height:42px;
    display:block;
    margin:auto;
  }
  .piece-box span{
    display:block;
    font-size:10px;
    margin-top:3px;
    color:#333;
    font-weight:600;
  }
  .rules-list{
  list-style:none;
  padding:0;
  margin:0 0 12px 0;
}

.rules-list li{
  margin-bottom:10px;
  text-align: justify;
  text-justify: inter-word;
  text-align-last: left;   /* ✅ last line justify nahi hogi */
  font-size:14px;
  line-height:1.4;
  color:#111;
}

  /* Promo modal */
  #promoModal{
    position:fixed;
    left:0;top:0;right:0;bottom:0;
    display:none;
    align-items:center;
    justify-content:center;
    background:rgba(2,6,23,0.6);
    z-index:9999;
  }
  .promoCard{
    background:#021528;
    padding:14px;
    border-radius:10px;
    display:flex;
    gap:12px;
    align-items:center;
  }
  .promoCard img{
    width:56px;
    height:56px;
    cursor:pointer;
    filter:drop-shadow(0 6px 18px rgba(0,0,0,0.6));
  }

  @media(max-width:1100px){
    .board-wrap{
      flex-direction:column;
      align-items:center;
    }
    aside.info-panel{
      width:100%;
      flex:0 0 auto;
    }
    .file-labels,.rank-labels{display:none;} /* optional mobile */
    #board{
      width:calc(100vw - 120px);
      max-width:none;
    }
    .board-row-wrap{
      max-width:none;
    }
  }


/* ===== Setup Required Popup ===== */
#setupMsg{
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.65);
  display: none;
  align-items: center;
  justify-content: center;
  z-index: 99999;
  animation: fadeIn 0.3s ease;
}

#setupMsg .box{
  background: #fff;
  width: 92%;
  max-width: 420px;
  border-radius: 14px;
  padding: 22px 20px 20px;
  text-align: center;
  box-shadow: 0 20px 60px rgba(0,0,0,0.35);
  position: relative;
  animation: scaleIn 0.35s ease;
  font-family: system-ui, -apple-system, Segoe UI, sans-serif;
}

/* Title */
#setupMsg h3{
  margin: 0 0 12px;
  font-size: 20px;
  color: #111;
}

/* Message text */
#setupMsg p{
  font-size: 15px;
  line-height: 1.6;
  color: #333;
  margin-bottom: 18px;
}

/* Highlight text */
#setupMsg b{
  color: #c62828;
}

/* OK button */
#setupMsg button{
  background: linear-gradient(135deg,#111,#333);
  color: #fff;
  border: none;
  padding: 10px 22px;
  font-size: 14px;
  border-radius: 22px;
  cursor: pointer;
  transition: transform .15s ease, box-shadow .15s ease;
}

#setupMsg button:hover{
  transform: translateY(-1px);
  box-shadow: 0 6px 16px rgba(0,0,0,0.3);
}

/* Close (X) button */
#setupMsg .close{
  position: absolute;
  top: 10px;
  right: 12px;
  font-size: 20px;
  color: #666;
  cursor: pointer;
  transition: color .2s ease, transform .2s ease;
}

#setupMsg .close:hover{
  color: #000;
  transform: scale(1.1);
}

/* Animations */
@keyframes fadeIn{
  from{opacity:0}
  to{opacity:1}
}

@keyframes scaleIn{
  from{transform:scale(.85)}
  to{transform:scale(1)}
}


/* ===============================
   CHESS 9x9 – SOFT 1px 3D SQUARES
   =============================== */

#board{
  perspective: 600px;
}

/* chess squares */
.cell{
  transition:
    transform 0.15s ease,
    box-shadow 0.15s ease;
  transform-style: preserve-3d;

  box-shadow:
    inset 1px 1px 2px rgba(255,255,255,0.45),
    inset -1px -1px 2px rgba(0,0,0,0.45),
    0 1px 3px rgba(0,0,0,0.35);
}

/* hover = very slight lift */
.cell:hover{
  transform: translateY(-1px);
  box-shadow:
    inset 1px 1px 2px rgba(255,255,255,0.55),
    inset -1px -1px 2px rgba(0,0,0,0.55),
    0 3px 6px rgba(0,0,0,0.45);
}

/* selected square */
.cell.selected{
  transform: translateY(-1px);
  box-shadow:
    inset 1px 1px 2px rgba(255,255,255,0.6),
    inset -1px -1px 2px rgba(0,0,0,0.6),
    0 4px 8px rgba(0,0,0,0.55);
}

</style>
</head>
<body>
<div class="container">

  <header class="app">
    <div class="brand">
      <img src="img/Logo.png" class="logo">
      <div>
        <h1>TheGrandChess9</h1>
        <div class="small">Software Develop by : <strong>Jitendra Surana & Rishab Surana</strong></div>
      </div>
    </div>

    <button id="infoBtn" style="
      margin-top:10px;
      background:#fff;
      border:1px solid #666;
      padding:8px 14px;
      border-radius:8px;
      font-weight:800;
      cursor:pointer;
    ">
      Rules of the Game and Pieces Information
    </button>

    <!-- RULES POPUP -->
    <div id="infoPopup" style="
      display:none;
      position:fixed;
      top:0;left:0;
      width:100%;height:100%;
      background:rgba(0,0,0,0.6);
      z-index:9999;
    ">
      <div style="
        width:100%;max-width:700px;
        background:#fff;color:#222;
        padding:20px;border-radius:10px;
        margin:60px auto;
        max-height:80vh;overflow-y:auto;
      ">
        <h1 style="margin-top:0;">Rules of the Game & Pieces Information</h1>
        <ul class="rules-list">
          <li>⏩ <strong>BOARD SIZE:</strong> Standard chess is played on an 8×8 board containing 64 squares.
      TheGrandChess9 expands the battlefield to a 9×9 board consisting of 81 squares,
      allowing for new strategies and piece interactions.</li>
          <li>⏩ <strong>EXTRA PAWN:</strong> Each player starts with 10 pawns on the 9×9 board.
      Before the game begins, both players are allowed to place 2 additional pawns.
      White places these pawns on Rank 3, while Black places them on Rank 7. Pawn movement follows traditional chess rules: pawns may move two squares on their first move,
      one square afterward, capture diagonally, and promote upon reaching the final rank.</li>
          <li>⏩ <strong>CHARIOTEER (c):</strong> Charioteer must always remain adjacent to its own King.
      It must occupy one of the eight surrounding squares of the King,
      including horizontal, vertical, and diagonal positions.The Charioteer may move freely around the King, provided that it remains adjacent after every move.The Charioteer is a defensive piece. It cannot capture any other piece,
      and no piece on the board is allowed to capture the Charioteer.If the King moves and the Charioteer is no longer adjacent,
      the player is granted one extra move to reposition the Charioteer next to the King.
      All check-related rules continue to apply normally.</li>
          <li>⏩ <strong>SCEPTRE (s):</strong> The Sceptre is a powerful piece that combines the movement abilities
      of the Bishop, Rook, and Knight.</li>
          <li>⏩ <strong>RENAMED:</strong> In TheGrandChess9, the Rook is called <strong>Airavat</strong>, and the Queen is called <strong>Commander</strong>.
      Castling is not permitted in this variant.</li>
          <li>⏩ <strong>OTHER RULES:</strong> All remaining rules follow classic chess, including Check, Checkmate,En Passant, and Stalemate. White always moves first. </li>
        </ul>

        <h2 style="text-align:center;margin:10px 0;">The Grand Chess 9 – Pieces Information</h2>
        <div class="compact-row">
          <div class="piece-box"><img src="img/wk.png"><span>KING</span></div>
          <div class="piece-box"><img src="img/wc.png"><span>CHARIOTEER</span></div>
          <div class="piece-box"><img src="img/ws.png"><span>SCEPTRE</span></div>
          <div class="piece-box"><img src="img/wq.png"><span>COMMANDER</span></div>
          <div class="piece-box"><img src="img/wr.png"><span>AIRAVAT</span></div>
          <div class="piece-box"><img src="img/wb.png"><span>BISHOP</span></div>
          <div class="piece-box"><img src="img/wn.png"><span>KNIGHT</span></div>
          <div class="piece-box"><img src="img/wp.png"><span>PAWN</span></div>
        </div>
        <div class="compact-row">
          <div class="piece-box"><img src="img/bk.png"><span>KING</span></div>
          <div class="piece-box"><img src="img/bc.png"><span>CHARIOTEER</span></div>
          <div class="piece-box"><img src="img/bs.png"><span>SCEPTRE</span></div>
          <div class="piece-box"><img src="img/bq.png"><span>COMMANDER</span></div>
          <div class="piece-box"><img src="img/br.png"><span>AIRAVAT</span></div>
          <div class="piece-box"><img src="img/bb.png"><span>BISHOP</span></div>
          <div class="piece-box"><img src="img/bn.png"><span>KNIGHT</span></div>
          <div class="piece-box"><img src="img/bp.png"><span>PAWN</span></div>
        </div>

        <button onclick="closeInfo()" style="
          margin-top:10px;
          background:#222;color:#fff;border:none;
          padding:8px 16px;border-radius:8px;cursor:pointer;
        ">Close</button>
      </div>
    </div>

    <div class="controls">
      <button id="btnHvh" class="mode-btn">Human vs Human</button>
      <button id="btnHvc" class="mode-btn">Human vs Computer</button>
      <button id="btnHvo" class="mode-btn active">Human vs Online</button>
      <button id="startBtn" class="action-btn">Start Pawn Placement</button>
      <div class="controls-bottom">
        <button id="resetBtn" class="action-btn ghost">Reset</button>
        <button id="undoBtn" class="action-btn ghost">Undo</button>
        <button id="flipBtn" class="action-btn ghost">Flip</button>
      </div>
      <div id="roomBadge" class="room-badge"></div>
    </div>
  </header>

  <div class="board-wrap">
    <div class="board-panel">
      <div class="board-row-wrap">
        <div class="rank-labels" aria-hidden="true">
          <div class="rank-label">9</div><div class="rank-label">8</div><div class="rank-label">7</div>
          <div class="rank-label">6</div><div class="rank-label">5</div><div class="rank-label">4</div>
          <div class="rank-label">3</div><div class="rank-label">2</div><div class="rank-label">1</div>
        </div>
        <div id="board" aria-label="Chess board"></div>
      </div>
      <div class="file-labels" aria-hidden="true">
        <div class="file-label">a</div><div class="file-label">b</div><div class="file-label">c</div>
        <div class="file-label">d</div><div class="file-label">e</div><div class="file-label">f</div>
        <div class="file-label">g</div><div class="file-label">h</div><div class="file-label">i</div>
      </div>
    </div>

    <aside class="info-panel">
      <div class="status" id="statusBox">Mode: Human vs Online — Pawn placement not started</div>
      <div class="small" id="pawnPhaseInfo">Pawn placement: —</div>
      <div><strong class="small">Turn:</strong> <span id="turnInfo">—</span></div>
      <div><strong class="small">Halfmove:</strong> <span id="halfmove">0</span></div>
      <div style="margin-top:6px"><strong class="small">Moves:</strong></div>
      <div class="moves" id="movesLog"></div>
      <div style="display:flex;gap:8px;flex-wrap:wrap">
        <button id="btnClearHistory" class="action-btn ghost">Clear History</button>
        <button id="btnExport" class="action-btn ghost">Export FEN</button>
      </div>
      <div style="margin-top:8px" class="small">TheGrandChess9</div>
    </aside>
  </div>

  <footer>Enjoy — TheGrandChess9 (modern rebuild)</footer>
</div>

<div id="promoModal">
  <div class="promoCard">
    <div style="font-weight:800;color:var(--white)">Promote to:</div>
    <img src="img/wq.png" data-piece="q" class="promoOpt">
    <img src="img/wr.png" data-piece="r" class="promoOpt">
    <img src="img/wb.png" data-piece="b" class="promoOpt">
    <img src="img/wn.png" data-piece="n" class="promoOpt">
  </div>
</div>

<script>
const files = ['a','b','c','d','e','f','g','h','i'];
const ranks = ['9','8','7','6','5','4','3','2','1'];

const boardEl = document.getElementById('board');
const statusBox = document.getElementById('statusBox');
const pawnPhaseInfo = document.getElementById('pawnPhaseInfo');
const turnInfo = document.getElementById('turnInfo');
const halfmoveEl = document.getElementById('halfmove');
const movesLog = document.getElementById('movesLog');
const promoModal = document.getElementById('promoModal');
const roomBadge = document.getElementById('roomBadge');

const btnHvh = document.getElementById('btnHvh');
const btnHvc = document.getElementById('btnHvc');
const btnHvo = document.getElementById('btnHvo');
const startBtn = document.getElementById('startBtn');
const resetBtn = document.getElementById('resetBtn');
const undoBtn = document.getElementById('undoBtn');
const flipBtn = document.getElementById('flipBtn');

const btnClearHistory = document.getElementById('btnClearHistory');
const btnExport = document.getElementById('btnExport');

/* modes */
let currentMode = 'hvo';
let aiEnabled = false;
let aiColor = 'b';
let roomId = null;
let localPlayerColor = null; // for HVO parent-assigned color

/* game state */
let boardState = {};
let turn = 'w';
let flipped = false;
let selected = null;
let legalMoves = [];
let enPassantTarget = null;
let halfmoveClock = 0;
let fullmoveNumber = 1;
let moveHistory = [];
let lastMove = null;

/* pawn placement */
let pawnPlacePhase = false;
let pawnPlaceColor = 'w';
let placedW = 0;
let placedB = 0;
const PLACEMENT_MAX = 2;

/* special */
let awaitingCharioteer = false;
let charioteerAwaitColor = null;
let pendingPromotion = null;

/* helpers */
function rcToCoord(r,c){ return files[c] + ranks[r]; }
function coordToRC(coord){ return [ranks.indexOf(coord[1]), files.indexOf(coord[0])]; }
function inside(r,c){ return r>=0 && r<9 && c>=0 && c<9; }
function makePiece(code, startRank = null){ return { code, c: code[0], t: code[1], moved:false, promoted:false, startRank }; }
function snapshotState(){ return JSON.parse(JSON.stringify({ boardState, turn, enPassantTarget, halfmoveClock, fullmoveNumber, lastMove, awaitingCharioteer, charioteerAwaitColor, pawnPlacePhase, pawnPlaceColor, placedW, placedB })); }
function restoreState(s){
  boardState = JSON.parse(JSON.stringify(s.boardState));
  turn = s.turn; enPassantTarget = s.enPassantTarget; halfmoveClock = s.halfmoveClock; fullmoveNumber = s.fullmoveNumber;
  lastMove = s.lastMove; awaitingCharioteer = s.awaitingCharioteer; charioteerAwaitColor = s.charioteerAwaitColor;
  pawnPlacePhase = !!s.pawnPlacePhase; pawnPlaceColor = s.pawnPlaceColor || 'w';
  placedW = s.placedW || 0; placedB = s.placedB || 0;
}

const PIECE_VALUES={p:100,n:300,b:200,r:400,q:600,k:20000,c:50,s:900};

/* initial setup */
function resetBoardState(){
  boardState = {};
  const b9 = ['br','bb','bn','bs','bk','bq','bb','bn','br'];
  for(let i=0;i<9;i++) boardState[files[i]+'9'] = makePiece(b9[i], '9');
  const b8 = ['bp','bp','bp','bp','bc','bp','bp','bp','bp'];
  for(let i=0;i<9;i++) boardState[files[i]+'8'] = makePiece(b8[i], '8');
  const w2 = ['wp','wp','wp','wp','wc','wp','wp','wp','wp'];
  for(let i=0;i<9;i++) boardState[files[i]+'2'] = makePiece(w2[i], '2');
  const w1 = ['wr','wn','wb','wq','wk','ws','wn','wb','wr'];
  for(let i=0;i<9;i++) boardState[files[i]+'1'] = makePiece(w1[i], '1');
}
resetBoardState();

/* render */
function renderBoard(){
  boardEl.innerHTML = '';
  for(let r=0;r<9;r++){
    for(let c=0;c<9;c++){
      const uiCoord = rcToCoord(r,c);
      let displayCoord = uiCoord;
      if(flipped){
        const [rr,cc] = coordToRC(uiCoord);
        displayCoord = rcToCoord(8-rr, 8-cc);
      }
      const cell = document.createElement('div');
      cell.className = 'cell ' + (((r+c)%2===0) ? 'light' : 'dark');
      cell.dataset.coord = displayCoord;
      const p = boardState[displayCoord];
      if(p){
        const img = document.createElement('img');
        img.className = 'piece';
        img.src = 'img/' + p.code + '.png';
        img.alt = p.code;
        cell.appendChild(img);
      }
      if(lastMove && (lastMove.from === displayCoord || lastMove.to === displayCoord)) cell.classList.add('last-move');
      cell.onclick = ()=> onCellClick(displayCoord);
      boardEl.appendChild(cell);
    }
  }
  updateUI();
}

/* update UI */
function updateUI(){
  const modeText = (currentMode==='hvh') ? 'Human vs Human' : (currentMode==='hvc') ? 'Human vs Computer' : 'Human vs Online';
  if(pawnPlacePhase){
    statusBox.textContent = `Mode: ${modeText} — Pawn placement: ${pawnPlaceColor === 'w' ? 'White' : 'Black' } (${ (pawnPlaceColor==='w') ? (PLACEMENT_MAX - placedW) : (PLACEMENT_MAX - placedB) } left)`;
    pawnPhaseInfo.textContent = `Place ${ (pawnPlaceColor==='w') ? (PLACEMENT_MAX - placedW) : (PLACEMENT_MAX - placedB) } pawn(s) on rank ${ pawnPlaceColor === 'w' ? '3' : '7' }`;
  } else {
    statusBox.textContent = `Mode: ${modeText} — ${turn === 'w' ? 'White' : 'Black'} to move`;
    pawnPhaseInfo.textContent = `Pawn placement complete (W:${placedW} B:${placedB})`;
  }
  turnInfo.textContent = turn === 'w' ? 'White' : 'Black';
  halfmoveEl.textContent = halfmoveClock;

  document.querySelectorAll('.cell').forEach(el => el.classList.remove('selected','highlight','c-choose'));
  if(selected){
    const sel = document.querySelector(`.cell[data-coord="${selected}"]`);
    if(sel) sel.classList.add('selected');
    for(const m of legalMoves){
      const tEl = document.querySelector(`.cell[data-coord="${m.to}"]`);
      if(tEl) tEl.classList.add('highlight');
    }
  }

  if(awaitingCharioteer){
    const king = findKing(charioteerAwaitColor);
    if(king){
      for(let dr=-1;dr<=1;dr++) for(let dc=-1;dc<=1;dc++){
        if(dr===0 && dc===0) continue;
        const tr = king[0]+dr, tc = king[1]+dc;
        if(inside(tr,tc)){
          const coord = rcToCoord(tr,tc);
          const el = document.querySelector(`.cell[data-coord="${coord}"]`);
          if(el && !boardState[coord]) el.classList.add('c-choose');
        }
      }
    }
  }

  movesLog.innerHTML = '';
  const list = moveHistory.map(h=> moveToAlgebraic(h.move));
  for(let i=0;i<list.length;i+=2){
    const li = document.createElement('div');
    li.textContent = ((i/2)+1) + '. ' + (list[i]||'') + (list[i+1] ? '  ' + list[i+1] : '');
    movesLog.appendChild(li);
  }
}

/* Pawn placement */
function startPawnPlacement(){
  resetBoardState();
  pawnPlacePhase = true; pawnPlaceColor = 'w'; placedW = 0; placedB = 0;
  selected = null; legalMoves = []; enPassantTarget = null; moveHistory = []; lastMove = null; awaitingCharioteer = false;
  renderBoard();
  if(currentMode === 'hvc' && aiColor === 'w'){ setTimeout(()=> aiAutoPlaceTwo('w'), 120); }
  postStateToParent();
}
startBtn.onclick = startPawnPlacement;

function handlePawnPlacement(coord){
  if(!pawnPlacePhase) return;
  const allowedRank = pawnPlaceColor === 'w' ? '3' : '7';
  if(coord[1] !== allowedRank) return;
  if(boardState[coord]) return;
  if(currentMode === 'hvo' && localPlayerColor){
    if(localPlayerColor !== pawnPlaceColor) return;
  }
  boardState[coord] = makePiece(pawnPlaceColor + 'p', null);
  if(pawnPlaceColor === 'w') placedW++; else placedB++;
  renderBoard();
  postStateToParent();
  if(pawnPlaceColor === 'w' && placedW >= PLACEMENT_MAX){
    pawnPlaceColor = 'b';
    if(currentMode === 'hvc' && aiColor === 'b'){ setTimeout(()=> aiAutoPlaceTwo('b'), 120); }
    renderBoard(); postStateToParent(); return;
  }
  if(pawnPlaceColor === 'b' && placedB >= PLACEMENT_MAX){
    pawnPlacePhase = false; pawnPlaceColor = 'b'; turn = 'w'; renderBoard(); postStateToParent(); return;
  }
}

/* AI pawn auto placement */
function aiAutoPlaceTwo(color){
  if(!pawnPlacePhase) return;
  const allowedRank = color === 'w' ? '3' : '7';
  const pref = ['e','d','f','c','g','b','h','a','i'];
  let placed = 0;
  for(const f of pref){
    const coord = f + allowedRank;
    if(!boardState[coord]){
      boardState[coord] = makePiece(color+'p', null);
      placed++; if(placed >= PLACEMENT_MAX) break;
    }
  }
  if(color === 'w') placedW += placed; else placedB += placed;
  if(color === 'w'){
    pawnPlaceColor = 'b'; renderBoard(); postStateToParent();
    if(currentMode==='hvc' && aiColor==='b') setTimeout(()=> aiAutoPlaceTwo('b'), 150);
  } else {
    pawnPlacePhase = false; turn = 'w'; renderBoard(); postStateToParent();
  }
}

/* Selection & clicks */
function onCellClick(coord){


if (!pawnPlacePhase && (placedW < 2 || placedB < 2)) {
    document.getElementById("setupMsg").style.display = "flex";
    return;
  }



  if(pawnPlacePhase){
    if(currentMode === 'hvc' && pawnPlaceColor === aiColor) return;
    if(currentMode === 'hvo' && localPlayerColor){
      if(localPlayerColor !== pawnPlaceColor) return;
    }
    handlePawnPlacement(coord); return;
  }
  if(pendingPromotion) return;
  if(awaitingCharioteer){
    const p = boardState[coord];
    if(!selected){
      if(p && p.t === 'c' && p.c === charioteerAwaitColor){
        selected = coord; legalMoves = generateLegalMovesForSquare(selected); updateUI();
      }
      return;
    } else {
      const mv = legalMoves.find(m=> m.to === coord);
      if(mv){
        applyMoveAndSync(mv);
        awaitingCharioteer = false; charioteerAwaitColor = null;
        selected = null; legalMoves = []; renderBoard();
      } else { selected = null; legalMoves = []; updateUI(); }
      return;
    }
  }

  const p = boardState[coord];

  // FIX 2: HVO me sirf apne color ki turn par hi move allow
  if(currentMode === 'hvo' && localPlayerColor){
    if(turn !== localPlayerColor) return;
  }

  if(!selected){
    if(!p) return;

    // FIX 2: HVO me opponent piece select hi nahi kar sakta
    if(currentMode === 'hvo' && localPlayerColor){
      if(p.c !== localPlayerColor) return;
    }

    if(p.c !== turn) return;
    selected = coord; legalMoves = generateLegalMovesForSquare(selected); updateUI(); return;
  } else {
    if(p && p.c === turn){
      selected = coord; legalMoves = generateLegalMovesForSquare(selected); updateUI(); return;
    }
    const mv = legalMoves.find(m => m.to === coord);
    if(!mv){ selected = null; legalMoves = []; updateUI(); return; }
    if(mv.special === 'promotion'){ pendingPromotion = mv; openPromotionModal(mv.piece.c); return; }
    applyMoveAndSync(mv);
    selected = null; legalMoves = [];
    renderBoard();
    if(currentMode === 'hvc' && turn === aiColor) setTimeout(()=> aiMakeMove(), 220);
  }
}

/* Move generation */
function generatePseudoMovesForPawn(from){
  const p = boardState[from]; if(!p) return [];
  const [fr,fc] = coordToRC(from);
  const dir = (p.c === 'w') ? -1 : 1;
  const moves = [];
  const oneR = fr + dir, twoR = fr + 2*dir;
  if(inside(oneR,fc) && !boardState[rcToCoord(oneR,fc)]){
    if((p.c === 'w' && oneR === 0) || (p.c === 'b' && oneR === 8)){
      moves.push({ from, to: rcToCoord(oneR,fc), piece: p, special:'promotion' });
    } else {
      moves.push({ from, to: rcToCoord(oneR,fc), piece: p });
      if(!p.moved && !p.promoted && (p.startRank === '2' || p.startRank === '8')){
        const curRank = from[1];
        if(curRank === p.startRank && inside(twoR,fc) && !boardState[rcToCoord(twoR,fc)]) moves.push({ from, to: rcToCoord(twoR,fc), piece: p, special:'double' });
      }
    }
  }
  for(const dc of [-1,1]){
    const tr = fr + dir, tc = fc + dc;
    if(!inside(tr,tc)) continue;
    const to = rcToCoord(tr,tc);
    const t = boardState[to];
    if(t && t.c !== p.c && t.t !== 'c'){
      if((p.c === 'w' && tr === 0) || (p.c === 'b' && tr === 8)) moves.push({ from, to, piece: p, captured: t, special:'promotion' });
      else moves.push({ from, to, piece: p, captured: t });
    } else {
      if(enPassantTarget === to) moves.push({ from, to, piece: p, special:'enpassant' });
    }
  }
  return moves;
}

function generatePseudoMovesForSquareCoord(coord){
  const p = boardState[coord]; if(!p) return [];
  const type = p.t;
  if(type === 'p') return generatePseudoMovesForPawn(coord);
  const [r,c] = coordToRC(coord);
  const list = [];
  function push(fr,fc,tr,tc,special=null){
    if(!inside(tr,tc)) return;
    const to = rcToCoord(tr,tc), target = boardState[to];
    if(target && target.t === 'c' && type !== 'c') return;
    if(type === 'c' && target) return;
    if(!target || target.c !== p.c) list.push({ from: rcToCoord(fr,fc), to, piece: p, captured: target?target:null, special});
  }
  if(type === 'n' || type === 's'){
    const deltas = [[2,1],[2,-1],[-2,1],[-2,-1],[1,2],[1,-2],[-1,2],[-1,-2]];
    for(const [dr,dc] of deltas) push(r,c,r+dr,c+dc);
    if(type === 'n') return list;
  }
  if(type === 'r' || type === 'q' || type === 's'){
    const orth = [[1,0],[-1,0],[0,1],[0,-1]];
    for(const [dr,dc] of orth){
      let tr=r+dr, tc=c+dc;
      while(inside(tr,tc)){
        const to = rcToCoord(tr,tc);
        if(!boardState[to]) { push(r,c,tr,tc); } else { if(boardState[to].t !== 'c' && boardState[to].c !== p.c) push(r,c,tr,tc); break; }
        tr+=dr; tc+=dc;
      }
    }
  }
  if(type === 'b' || type === 'q' || type === 's'){
    const diag = [[1,1],[1,-1],[-1,1],[-1,-1]];
    for(const [dr,dc] of diag){
      let tr=r+dr, tc=c+dc;
      while(inside(tr,tc)){
        const to = rcToCoord(tr,tc);
        if(!boardState[to]) { push(r,c,tr,tc); } else { if(boardState[to].t !== 'c' && boardState[to].c !== p.c) push(r,c,tr,tc); break; }
        tr+=dr; tc+=dc;
      }
    }
  }
  if(type === 'c'){
    const king = findKing(p.c);
    if(!king) return list;
    for(let dr=-1;dr<=1;dr++) for(let dc=-1;dc<=1;dc++){
      if(dr===0 && dc===0) continue;
      const tr = king[0]+dr, tc = king[1]+dc;
      if(inside(tr,tc) && !boardState[rcToCoord(tr,tc)]) push(r,c,tr,tc);
    }
  }
  if(type === 'k'){
    for(let dr=-1;dr<=1;dr++) for(let dc=-1;dc<=1;dc++){
      if(dr===0 && dc===0) continue;
      const tr=r+dr, tc=c+dc;
      if(!inside(tr,tc)) continue;
      const to = rcToCoord(tr,tc);
      const tt = boardState[to];
      if(!tt || tt.c !== p.c){
        if(tt && tt.t === 'c') continue;
        list.push({ from: rcToCoord(r,c), to, piece: p, captured: tt?tt:null});
      }
    }
  }
  return list;
}

/* legal filter */
function generateLegalMovesForSquare(coord){
  const p = boardState[coord]; if(!p) return [];
  const pseudo = generatePseudoMovesForSquareCoord(coord);
  const legal = [];
  for(const m of pseudo){
    const snapshot = snapshotState();
    makeMoveOnState(m);
    const inCheck = isKingInCheck(p.c);
    restoreState(snapshot);
    if(!inCheck) legal.push(m);
  }
  return legal;
}

/* apply move on state */
function makeMoveOnState(m){
  const from = m.from, to = m.to;
  const piece = boardState[from];
  if(!piece) return;
  if(m.special === 'enpassant'){
    const [tr,tc] = coordToRC(to);
    const capR = (piece.c === 'w') ? tr+1 : tr-1;
    const capCoord = rcToCoord(capR,tc);
    delete boardState[capCoord];
  }
  if(boardState[to]) delete boardState[to];
  boardState[to] = JSON.parse(JSON.stringify(piece));
  boardState[to].moved = true;
  if(m.special === 'promotion'){
    boardState[to].promoted = true;
    const promotedTo = m.promotionTo || 'q';
    boardState[to].t = promotedTo;
    boardState[to].code = boardState[to].c + promotedTo;
  }
  delete boardState[from];
  if(m.special === 'double'){
    const [fr,fc] = coordToRC(from); const [tr,tc] = coordToRC(to);
    const midR = Math.round((fr+tr)/2);
    enPassantTarget = rcToCoord(midR, fc);
  } else { enPassantTarget = null; }
}

/* APPLY MOVE (with charioteer handling, original logic kept) */
function applyMove(m){
  const snap = snapshotState();
  makeMoveOnState(m);
  lastMove = { from: m.from, to: m.to };
  if((m.piece && m.piece.t === 'p') || m.captured) halfmoveClock = 0; else halfmoveClock++;

  const movedPiece = m.piece || (boardState[m.to] ? boardState[m.to] : null);

  if(movedPiece && movedPiece.t === 'k'){
    const color = movedPiece.c;
    const kingPos = findKing(color);
    const cpos = findCharioteer(color);

    if(cpos && !isAdjacent(kingPos, cpos)){
      if(currentMode === 'hvc' && aiColor === color){
        moveHistory.push({ snapshot: snap, move: m });
        const targets = [];
        const pref = [[0,0],[0,-1],[0,1],[ -1,0],[1,0],[-1,-1],[-1,1],[1,-1],[1,1]];
        for(const [dr,dc] of pref){
          const tr = kingPos[0] + dr, tc = kingPos[1] + dc;
          if(inside(tr,tc)){
            const coord = rcToCoord(tr,tc);
            if(!boardState[coord]) targets.push(coord);
          }
        }
        if(targets.length){
          const fromCoord = rcToCoord(cpos[0], cpos[1]);
          const toCoord = targets[0];
          const chMove = { from: fromCoord, to: toCoord, piece: boardState[fromCoord] };

          makeMoveOnState(chMove);
          const snapAfterCh = snapshotState();
          moveHistory.push({ snapshot: snapAfterCh, move: chMove });

          awaitingCharioteer = false; charioteerAwaitColor = null;
          lastMove = { from: chMove.from, to: chMove.to };
          flipTurnAfterMove();
          postStateToParent();
          renderBoard();
          return;
        }
      }
      awaitingCharioteer = true;
      charioteerAwaitColor = color;
      moveHistory.push({ snapshot: snap, move: m });
      postStateToParent();
      renderBoard();
      return;
    }
  }

  if(movedPiece && movedPiece.t === 'c' && awaitingCharioteer && charioteerAwaitColor === movedPiece.c){
    const kingPos = findKing(movedPiece.c);
    const cpos = findCharioteer(movedPiece.c);
    if(cpos && isAdjacent(kingPos,cpos)){
      awaitingCharioteer = false; charioteerAwaitColor = null;
      flipTurnAfterMove();
      moveHistory.push({ snapshot: snap, move: m });
      postStateToParent();
      renderBoard();
      return;
    }
  }

  flipTurnAfterMove();
  moveHistory.push({ snapshot: snap, move: m });
  postStateToParent();
}

/* wrapper */
function applyMoveAndSync(m){ applyMove(m); }

/* undo/flip helpers */
function undo(){
  if(moveHistory.length === 0) return;
  const last = moveHistory.pop();
  restoreState(last.snapshot);
  renderBoard();
}
undoBtn.onclick = undo;

function flipBoard(){ flipped = !flipped; renderBoard(); }
flipBtn.onclick = flipBoard;

function flipTurnAfterMove(){
  if(turn === 'b') fullmoveNumber++;
  turn = (turn === 'w') ? 'b' : 'w';
  renderBoard();
}

/* find pieces */
function findKing(color){
  for(let r=0;r<9;r++) for(let c=0;c<9;c++){
    const coord = rcToCoord(r,c);
    const p = boardState[coord];
    if(p && p.t === 'k' && p.c === color) return [r,c];
  }
  return null;
}
function findCharioteer(color){
  for(let r=0;r<9;r++) for(let c=0;c<9;c++){
    const coord = rcToCoord(r,c);
    const p = boardState[coord];
    if(p && p.t === 'c' && p.c === color) return [r,c];
  }
  return null;
}
function isAdjacent(a,b){ if(!a||!b) return false; return Math.abs(a[0]-b[0])<=1 && Math.abs(a[1]-b[1])<=1; }

/* attack checks */
function isKingInCheck(color){
  const king = findKing(color);
  if(!king) return true;
  const [kr,kc] = king;
  const enemy = color === 'w' ? 'b' : 'w';
  for(let r=0;r<9;r++) for(let c=0;c<9;c++){
    const coord = rcToCoord(r,c); const p = boardState[coord];
    if(!p || p.c !== enemy) continue;
    const pseudo = generatePseudoMovesForSquareCoord(coord);
    for(const mv of pseudo){
      if(mv.to === rcToCoord(kr,kc)) return true;
    }
  }
  return false;
}

function generateAllLegalMovesForColor(color){
  const out = [];
  for(const coord in boardState){
    if(boardState[coord].c !== color) continue;
    const legal = generateLegalMovesForSquare(coord);
    for(const m of legal) out.push(m);
  }
  return out;
}

/* algebraic & promotions */
function moveToAlgebraic(m){
  const p = m.piece;
  const from = m.from, to = m.to;
  if(!p) return from + '-' + to;
  const pieceChar = p.t === 'p' ? '' : p.t.toUpperCase();
  const capture = m.captured ? 'x' : '-';
  const promo = m.special === 'promotion' ? '=' + (m.promotionTo?m.promotionTo.toUpperCase():'Q') : '';
  return (p.t === 'p' ? from + (m.captured ? 'x' + to : '-' + to) : pieceChar + from + capture + to) + promo;
}

function openPromotionModal(color){
  promoModal.querySelectorAll('.promoOpt').forEach(img=>{
    const kind = img.dataset.piece;
    img.src = `img/${color}${kind}.png`;
  });
  promoModal.style.display = 'flex';
}
promoModal.addEventListener('click',(e)=>{
  const opt = e.target.closest('.promoOpt');
  if(!opt){ promoModal.style.display = 'none'; pendingPromotion = null; return; }
  const pick = opt.dataset.piece;
  if(pendingPromotion){
    pendingPromotion.promotionTo = pick;
    applyMoveAndSync(pendingPromotion);
    pendingPromotion = null;
    promoModal.style.display = 'none';
    renderBoard();
  }
});

/* AI */
function aiMakeMove(){
  if(currentMode !== 'hvc') return;
  const color = aiColor;
  if(color !== turn) return;
  const moves = generateAllLegalMovesForColor(color);
  if(!moves || moves.length === 0) return;
  moves.sort((a,b)=>{
    let sa = (a.captured?1:0) + (a.special==='promotion'?3:0);
    let sb = (b.captured?1:0) + (b.special==='promotion'?3:0);
    return sb - sa;
  });
  const pick = moves[0];
  if(pick.special === 'promotion' && !pick.promotionTo) pick.promotionTo = 'q';
  setTimeout(()=> applyMoveAndSync(pick), 120);
}

/* ensure AI pawn placement */
function ensureAIAutoPlacement(){
  if(!pawnPlacePhase) return;
  if(currentMode === 'hvc' && pawnPlaceColor === aiColor) setTimeout(()=> aiAutoPlaceTwo(aiColor), 120);
}

/* parent sync placeholder */
function postStateToParent(){
  if(!roomId) return;
  parent.postMessage({
    type: 'sendMove',
    roomId,
    state: {
      boardState, turn, enPassantTarget, halfmoveClock, fullmoveNumber, awaitingCharioteer,
      pawnPlacePhase, pawnPlaceColor, placedW, placedB
    }
  }, '*');
}

/* receive sync */
window.addEventListener('message', (ev)=>{
  const msg = ev.data;
  if(!msg?.type) return;
  if(msg.type === 'setRoomId'){
    roomId = msg.roomId;
    roomBadge.style.display = 'inline-block';
    roomBadge.textContent = 'Room: ' + roomId;
    if(msg.playerColor){ localPlayerColor = msg.playerColor; roomBadge.textContent += ` (${localPlayerColor === 'w' ? 'White' : 'Black'})`; }
  }
  if(msg.type === 'setPlayerColor'){
    localPlayerColor = msg.playerColor;
    if(roomBadge.style.display !== 'inline-block') roomBadge.style.display = 'inline-block';
    roomBadge.textContent = `Room: ${roomId || '—'} (${localPlayerColor === 'w' ? 'White' : 'Black'})`;
  }
  if(msg.type === 'syncGame' && msg.state){
    const s = msg.state;
    if(s.boardState) boardState = s.boardState;
    if(typeof s.turn !== 'undefined') turn = s.turn;
    enPassantTarget = s.enPassantTarget || null;
    awaitingCharioteer = s.awaitingCharioteer || false;
    if(typeof s.pawnPlacePhase !== 'undefined') pawnPlacePhase = s.pawnPlacePhase;
    if(typeof s.pawnPlaceColor !== 'undefined') pawnPlaceColor = s.pawnPlaceColor;
    placedW = s.placedW || placedW;
    placedB = s.placedB || placedB;
    renderBoard();
  }
});

/* UI controls */
btnHvh.onclick = ()=> setMode('hvh');
btnHvc.onclick = ()=> setMode('hvc');
btnHvo.onclick = ()=> setMode('hvo');

// FIX 1: Reset par bhi pawn placement compulsory
resetBtn.onclick = ()=> { 
  resetBoardState();
  pawnPlacePhase = true;
  pawnPlaceColor = 'w';
  placedW = 0;
  placedB = 0;
  enPassantTarget = null;
  moveHistory = [];
  lastMove = null;
  awaitingCharioteer = false;
  turn = 'w';
  renderBoard();
};

btnClearHistory.onclick = ()=> { moveHistory = []; movesLog.innerHTML = ''; };
btnExport.onclick = ()=> { alert('Export not implemented in this rebuild — you can read boardState via window._G'); };

function setMode(m){
  currentMode = m;
  btnHvh.classList.remove('active'); btnHvc.classList.remove('active'); btnHvo.classList.remove('active');
  if(m === 'hvh') btnHvh.classList.add('active');
  if(m === 'hvc'){ btnHvc.classList.add('active'); aiEnabled = true; }
  if(m === 'hvo') btnHvo.classList.add('active');
  ensureAIAutoPlacement();
}

/* init */
renderBoard();
setMode('hvo');

window._G = { boardState, renderBoard, resetBoardState, startPawnPlacement, applyMoveAndSync, generateLegalMovesForSquare, aiMakeMove };

</script>
<script>
  // Open popup
  document.getElementById("infoBtn").onclick = function () {
    document.getElementById("infoPopup").style.display = "block";
  };

  // Close popup
  function closeInfo() {
    document.getElementById("infoPopup").style.display = "none";
  }
</script>

<div id="setupMsg">
  <div class="box">
    <span class="close"
      onclick="document.getElementById('setupMsg').style.display='none'">✖</span>

    <h3>Game Setup Required</h3>

    <p>
      Please <b>White Player</b> place <b>2 Pawns</b> on
      <b>Row-3</b> any square and
      <b>Black Player</b> place <b>2 Pawns</b> on
      <b>Row-7</b> any square </b>

<p> to this press button "Reset" and "Start Pawn Placement" 
    </p>

    <button
      onclick="document.getElementById('setupMsg').style.display='none'">
      OK
    </button>
  </div>
</div>
</body>
</html>

